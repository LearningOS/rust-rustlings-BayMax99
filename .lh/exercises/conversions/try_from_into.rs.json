{
    "sourceFile": "exercises/conversions/try_from_into.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1681642800089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1681643232282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,16 +37,44 @@\n // Tuple implementation\r\n impl TryFrom<(i16, i16, i16)> for Color {\r\n     type Error = IntoColorError;\r\n     fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {\r\n+        let red = match tuple.0.try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let green = match tuple.1.try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let blue = match tuple.2.try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        Ok(Self { red, green, blue })\r\n+\r\n     }\r\n-    \r\n+\r\n }\r\n \r\n // Array implementation\r\n impl TryFrom<[i16; 3]> for Color {\r\n     type Error = IntoColorError;\r\n     fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {\r\n+        let red = match arr[0].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let green = match arr[1].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let blue = match arr[2].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        Ok(Self { red, green, blue })\r\n+\r\n     }\r\n }\r\n \r\n // Slice implementation\r\n"
                },
                {
                    "date": 1681643243252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,8 +80,26 @@\n // Slice implementation\r\n impl TryFrom<&[i16]> for Color {\r\n     type Error = IntoColorError;\r\n     fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {\r\n+        if slice.len() != 3 {\r\n+            return Err(Self::Error::BadLen);\r\n+        }\r\n+\r\n+        let red = match slice[0].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let green = match slice[1].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        let blue = match slice[2].try_into() {\r\n+            Ok(x) => x,\r\n+            _ => return Err(Self::Error::IntConversion),\r\n+        };\r\n+        Ok(Self { red, green, blue })\r\n+\r\n     }\r\n }\r\n \r\n fn main() {\r\n"
                }
            ],
            "date": 1681642800089,
            "name": "Commit-0",
            "content": "// try_from_into.rs\r\n// TryFrom is a simple and safe type conversion that may fail in a controlled way under some circumstances.\r\n// Basically, this is the same as From. The main difference is that this should return a Result type\r\n// instead of the target type itself.\r\n// You can read more about it at https://doc.rust-lang.org/std/convert/trait.TryFrom.html\r\n// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for a hint.\r\n\r\nuse std::convert::{TryFrom, TryInto};\r\n\r\n#[derive(Debug, PartialEq)]\r\nstruct Color {\r\n    red: u8,\r\n    green: u8,\r\n    blue: u8,\r\n}\r\n\r\n// We will use this error type for these `TryFrom` conversions.\r\n#[derive(Debug, PartialEq)]\r\nenum IntoColorError {\r\n    // Incorrect length of slice\r\n    BadLen,\r\n    // Integer conversion error\r\n    IntConversion,\r\n}\r\n\r\n// I AM NOT DONE\r\n\r\n// Your task is to complete this implementation\r\n// and return an Ok result of inner type Color.\r\n// You need to create an implementation for a tuple of three integers,\r\n// an array of three integers, and a slice of integers.\r\n//\r\n// Note that the implementation for tuple and array will be checked at compile time,\r\n// but the slice implementation needs to check the slice length!\r\n// Also note that correct RGB color values must be integers in the 0..=255 range.\r\n\r\n// Tuple implementation\r\nimpl TryFrom<(i16, i16, i16)> for Color {\r\n    type Error = IntoColorError;\r\n    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {\r\n    }\r\n    \r\n}\r\n\r\n// Array implementation\r\nimpl TryFrom<[i16; 3]> for Color {\r\n    type Error = IntoColorError;\r\n    fn try_from(arr: [i16; 3]) -> Result<Self, Self::Error> {\r\n    }\r\n}\r\n\r\n// Slice implementation\r\nimpl TryFrom<&[i16]> for Color {\r\n    type Error = IntoColorError;\r\n    fn try_from(slice: &[i16]) -> Result<Self, Self::Error> {\r\n    }\r\n}\r\n\r\nfn main() {\r\n    // Use the `try_from` function\r\n    let c1 = Color::try_from((183, 65, 14));\r\n    println!(\"{:?}\", c1);\r\n\r\n    // Since TryFrom is implemented for Color, we should be able to use TryInto\r\n    let c2: Result<Color, _> = [183, 65, 14].try_into();\r\n    println!(\"{:?}\", c2);\r\n\r\n    let v = vec![183, 65, 14];\r\n    // With slice we should use `try_from` function\r\n    let c3 = Color::try_from(&v[..]);\r\n    println!(\"{:?}\", c3);\r\n    // or take slice within round brackets and use TryInto\r\n    let c4: Result<Color, _> = (&v[..]).try_into();\r\n    println!(\"{:?}\", c4);\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_tuple_out_of_range_positive() {\r\n        assert_eq!(\r\n            Color::try_from((256, 1000, 10000)),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_tuple_out_of_range_negative() {\r\n        assert_eq!(\r\n            Color::try_from((-1, -10, -256)),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_tuple_sum() {\r\n        assert_eq!(\r\n            Color::try_from((-1, 255, 255)),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_tuple_correct() {\r\n        let c: Result<Color, _> = (183, 65, 14).try_into();\r\n        assert!(c.is_ok());\r\n        assert_eq!(\r\n            c.unwrap(),\r\n            Color {\r\n                red: 183,\r\n                green: 65,\r\n                blue: 14\r\n            }\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_array_out_of_range_positive() {\r\n        let c: Result<Color, _> = [1000, 10000, 256].try_into();\r\n        assert_eq!(c, Err(IntoColorError::IntConversion));\r\n    }\r\n    #[test]\r\n    fn test_array_out_of_range_negative() {\r\n        let c: Result<Color, _> = [-10, -256, -1].try_into();\r\n        assert_eq!(c, Err(IntoColorError::IntConversion));\r\n    }\r\n    #[test]\r\n    fn test_array_sum() {\r\n        let c: Result<Color, _> = [-1, 255, 255].try_into();\r\n        assert_eq!(c, Err(IntoColorError::IntConversion));\r\n    }\r\n    #[test]\r\n    fn test_array_correct() {\r\n        let c: Result<Color, _> = [183, 65, 14].try_into();\r\n        assert!(c.is_ok());\r\n        assert_eq!(\r\n            c.unwrap(),\r\n            Color {\r\n                red: 183,\r\n                green: 65,\r\n                blue: 14\r\n            }\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_slice_out_of_range_positive() {\r\n        let arr = [10000, 256, 1000];\r\n        assert_eq!(\r\n            Color::try_from(&arr[..]),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_slice_out_of_range_negative() {\r\n        let arr = [-256, -1, -10];\r\n        assert_eq!(\r\n            Color::try_from(&arr[..]),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_slice_sum() {\r\n        let arr = [-1, 255, 255];\r\n        assert_eq!(\r\n            Color::try_from(&arr[..]),\r\n            Err(IntoColorError::IntConversion)\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_slice_correct() {\r\n        let v = vec![183, 65, 14];\r\n        let c: Result<Color, _> = Color::try_from(&v[..]);\r\n        assert!(c.is_ok());\r\n        assert_eq!(\r\n            c.unwrap(),\r\n            Color {\r\n                red: 183,\r\n                green: 65,\r\n                blue: 14\r\n            }\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_slice_excess_length() {\r\n        let v = vec![0, 0, 0, 0];\r\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\r\n    }\r\n    #[test]\r\n    fn test_slice_insufficient_length() {\r\n        let v = vec![0, 0];\r\n        assert_eq!(Color::try_from(&v[..]), Err(IntoColorError::BadLen));\r\n    }\r\n}\r\n"
        }
    ]
}